<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script async defer src ="https://maps.googleapis.com/maps/api/js?key=AIzaSyA7bzgLrMKMMzKdsdyzix9xUQ9XXPUS3X4&libraries=places"></script>
    <script>
        let markers = []; // Array to store marker references
        let nearbyMarkers = []; //Array to store markers near route
        let  directionsService, directionsRenderer;
        function initMap() {
            const mapCenter = { lat: 16.49495164522174, lng: 80.49914285090084 };

            // Create a map
            const map = new google.maps.Map(document.getElementById("map"), {
                center: mapCenter, // 
                zoom: 17,
                streetViewControl: false,  // Disable the Street View control
                mapTypeControl: false 
            });

             // Define a geographical bounds area for autocomplete suggestions
             const defaultBounds = {
                north: mapCenter.lat + 0.05,  // Adjust these values to set the bounds size
                south: mapCenter.lat - 0.05,
                east: mapCenter.lng + 0.05,
                west: mapCenter.lng - 0.05
            };

            const autocompleteOptions = {
                bounds: defaultBounds, 
                strictBounds: true, // Ensures suggestions are strictly within the bounds
                componentRestrictions: { country: "in" } // Restrict to a specific country (e.g., India "in")
            };

            // Initialize Autocomplete for start and end locations
            const startInput = document.getElementById('start');
            const endInput = document.getElementById('end');

            const autocompleteStart = new google.maps.places.Autocomplete(startInput, autocompleteOptions);
            const autocompleteEnd = new google.maps.places.Autocomplete(endInput, autocompleteOptions);

            const trafficLightIcon = {
                url: 'images/traffic.jpg', // Example traffic light icon
                scaledSize: new google.maps.Size(30, 30), // Scale the image size
                origin: new google.maps.Point(0, 0), // Origin of the image (top-left corner)
                anchor: new google.maps.Point(10, 10), // Anchor (where the marker points)
            };

            // Array containing data for multiple markers
            const markerData = [
                { lat: 16.495479996036146, lng: 80.49904188864451}, // Marker 1 16.495479996036146, 80.49904188864451
                { lat: 16.495588585360405, lng: 80.49919823460043 }, // Marker 2 16.495588585360405, 80.49919823460043
                { lat: 16.49547799734693, lng: 80.49929077081237 }, // Marker 3 16.49547799734693, 80.49929077081237
                { lat: 16.494887191750784, lng: 80.50002156551199 }, // Marker 4 16.494887191750784, 80.50002156551199
                { lat: 16.49487561854721, lng: 80.50008727963325 },  // Marker 5 16.49487561854721, 80.50008727963325
                { lat: 16.49413743410036, lng: 80.49852567068721 }   // Marker 6 16.49413743410036, 80.49852567068721
            ];

            // Loop through the markerData array to create markers
            markerData.forEach((data, index) => {
                const marker = new google.maps.Marker({
                    position: { lat: data.lat, lng: data.lng },
                    map: map,
                    icon: trafficLightIcon, 
                    title: `Marker ${index + 1}`,  // e.g., "Marker 1", "Marker 2", etc.
                });

                // Store the marker in the array
                markers.push(marker);
            });

            // Initialize Directions Service and Renderer
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer();
            directionsRenderer.setMap(map);

            // Listen for form submission to calculate the route
            document.getElementById('route-form').addEventListener('submit', function (event) {
                event.preventDefault(); // Prevent page reload
                calculateAndDisplayRoute();
            }); 
        }

        function calculateAndDisplayRoute() {
            const start = document.getElementById('start').value;
            const end = document.getElementById('end').value;

            if (start && end) {
                directionsService.route(
                    {
                        origin: start,   // Start location input by user
                        destination: end, // Destination input by user
                        travelMode: 'DRIVING', 
                    },
                    (response, status) => {
                        if (status === 'OK') {
                            directionsRenderer.setDirections(response); // Display the route on the map

                            // Extract the route path from the response
                            const routePath = response.routes[0].overview_path;
                            const interpolatedPoints = getInterpolatedPoints(routePath);
                            // Check markers on the route
                            checkMarkersOnRoute(interpolatedPoints);
                        } else {
                            window.alert('Directions request failed due to ' + status);
                        }
                    }
                );
            } 
            else {
                alert('Please enter both start and end locations.');
            }
        }

        // Function to get interpolated points along the route at 1-meter intervals
        function getInterpolatedPoints(routePath) {
            const interval = 0.1;
            const interpolatedPoints = [];
            for (let i = 0; i < routePath.length - 1; i++) 
            {
                const A = routePath[i];
                const B = routePath[i + 1];

                const segmentLength = google.maps.geometry.spherical.computeDistanceBetween(A, B);
                const numIntervals = Math.floor(segmentLength / interval);
                for (let j = 0; j <= numIntervals; j++) {
                    const t = j / numIntervals; // Normalized distance along the segment
                    const lat = A.lat() + t * (B.lat() - A.lat());
                    const lng = A.lng() + t * (B.lng() - A.lng());
                    interpolatedPoints.push(new google.maps.LatLng(lat, lng)); // Create a new LatLng point
                }
            }
            return interpolatedPoints;
        }

        function checkMarkersOnRoute(interpolatedPoints) {
            const distanceThreshold = 5; // Set threshold to 5 meters
            interpolatedPoints.forEach(inter => {
                markers.forEach(marker => {
                    const markerPosition = marker.getPosition();
                    const distance = google.maps.geometry.spherical.computeDistanceBetween(markerPosition, inter);
                    // Check if the marker is near the current route point
                    if (distance < distanceThreshold) {
                        if (!nearbyMarkers.includes(marker)) {
                            console.log(`${marker.getTitle()} is near route point.`);
                            nearbyMarkers.push(marker); // Add marker to the array
                        }
                    }
                });
            });
            startSendingMarkerValues();
        }
            
        // Function to continuously send marker values
        // function startSendingMarkerValues() {
        //     let markerIndex =0;
        //     const intervalId = setInterval(() => {
        //         if (markerIndex < nearbyMarkers.length) {
        //             const marker = nearbyMarkers[markerIndex];
        //             const markerValue = parseInt(marker.getTitle().substring(7));
        //             console.log(`Sending Marker Value: ${markerValue}`);
                    
        //             // Send the value to the ESP32
        //             sendLaneValue(markerValue);

        //             // Increment to move to the next marker in the next interval
        //             markerIndex++;
        //         } 
        //         else {
        //             // Stop the interval once all markers have been sent
        //             clearInterval(intervalId);
        //             console.log("All marker values have been sent.");
        //             // Stop displaying the route on the map
        //             window.alert('Route completed');
        //             window.location.reload();
        //         }
        //     }, 5000); // Sends marker values every 5 seconds
        // }


        async function startSendingMarkerValues() {
                let markerIndex = 0;

            // Loop through the markers
            while (markerIndex < nearbyMarkers.length) {
                const marker = nearbyMarkers[markerIndex]; 
                const markerValue = parseInt(marker.getTitle().substring(7));
                console.log(`Sending Marker Value: ${markerValue}`);
                
                try {
                    // Send the value to the ESP32 and wait for it to complete
                    await sendLaneValue(markerValue);
                    console.log(`Traffic light updated for lane ${markerValue}`);
                } catch (error) {
                    console.error('Error sending marker value:', error);
                }
                
                // Increment to move to the next marker
                markerIndex++;
            }

            console.log("All marker values have been sent.");
            // Stop displaying the route on the map
            window.alert('Route completed');
            window.location.reload();
        }

        // Function to map lane values to ESP32 IPs and send values
        async function sendLaneValue(lane) {
            // Define the mapping of lane values to ESP32 IP addresses
            const esp32Mapping = {
                1: '192.168.137.183', 
                2: '192.168.137.183',
                3: '192.168.137.183',
                4: '0',
                5: '0',
                6: '0',
                // Add more mappings as needed
            };

            // Select the ESP32 IP based on the lane value
            const esp32IP = esp32Mapping[lane];

            if (esp32IP) {
                const url = `http://${esp32IP}/set_lights?lane=${lane}`;

                // Send HTTP GET request and return a Promise
                return fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        return response.text();
                    })
                    .then(data => {
                        console.log(`Response from ESP32 :`, data);
                        return data; // Resolve with response data
                    })
                    .catch(error => {
                        //console.error('Error sending signal:', error);
                        throw error; // Propagate the error
                    });
            } else {
                console.error('No ESP32 mapping found for lane:', lane);
                throw new Error(`No mapping for lane: ${lane}`);
            }
        }
        
        function signOut() {
            // Redirect to your login page
            window.location.href = "login.html"; // Update this path with your actual login page
        }

        // Initialize the map when the page loads
        window.onload = () => {
            initMap();
        };
    </script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }
        #map {
            height: fit-content; /* Full height of the viewport */
            width: 100%; /* Full width */
            z-index: 0;
            position: relative; /* To position the form */
        }
        #route-form {
            position: absolute;
            top: 5px; /* Distance from the bottom */
            left: 1px; /* Distance from the left */
            background: rgba(255, 255, 255, 0); /* Semi-transparent background */
            padding: 10px;
            z-index: 1;
        }
        #start, #end {
            width: 250px;
            height: 30px;
            margin: 5px 0; /* Space between inputs */
            bottom: 10px;
            border-radius: 10px;
            border-color: rgb(255,255,255);
        }
        #start, #end :active{
            width: 250px;
            height: 30px;
            margin: 5px 0; /* Space between inputs */
            bottom: 10px;
            border-radius: 10px;
            border-color: rgba(0,0,0,0.5);
        }
        #sub:hover {
            background-color: rgb(82, 182, 182);
        }
        #sign-out-btn {
            position: absolute;
            top: 70px;
            right: 10px;
            padding: 10px 20px;
            background-color: red;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1;
        }
        #sign-out-btn:hover {
            background-color: darkred;
        }
    </style>
</head>
<body>
    <!-- Sign Out Button -->
    <button id="sign-out-btn" onclick="signOut()">Sign Out</button>

    <!-- Route search form -->
    <form id="route-form" style="margin-bottom: 10px;">
        <input id="start" type="text" placeholder="Enter starting location" ></br>
        <input id="end" type="text" placeholder="Enter destination">
        <button id="sub" type="submit" style="height: 30px; border-radius: 30px; border-color: rgba(0,0,0,0.67);">Get Route</button>
    </form>
    <div id="map" style="height: 642px; width: 100%;"></div>
</body>
</html>


